---
layout: article
---
Итак, атака через злонамеренный Jenkinsfile называется `Poisoned Pipeline Execution`. Скажем, у нас здесь организация, у нее есть мощности в облаке и своем датацентре. Там крутятся приложения и сервер с Jenkins, который имеет агентов в обеих средах. 

Предположим, что нерадивый разработчик выложил свой `personal access token` от приватного репозитория на Github в общедоступный  облачный бакет. В какой-то момент злоумышленник забрал этот токен и вычислил, где находится этот репо. В репозитории лежит Jenkisfile, который связан с пайплайном на контроллере в датацентре организации.

На первом этапе нападающий анализирует историю репозитория, а именно, как менялся Jenkinsfile, смотрит скрипты, README-файлы, pullrequests и вообще все, до чего там сможет дотянуться, чтобы узнать, какие виды `steps` поддерживает этот Jenkins, какие Groovy-скрипты разрешены в **Groovy Sandbox**, какие метки у агентов и какие названия есть у других jobs.

Далее коммитит новый Jenkinsfile в новую ветку или же прямо в эту, и в запущенном пайплайне собирает данные об агенте, на котором производится запуск.

Здесь небольшая ремарка. По умолчанию агенты Jenkins запускают свои сборки от внутреннего пользователя `SYSTEM`, у которого нет ограничений. К счастью, он не сможет что-то изменить на контроллере, но вот cможет удалить jobs или запустить сборки от имени этого пользователя.

Итак, запустив свою сборку на разных агентах, злоумышленники обычно делают следующее:

- ищут ценные файлы, созданные предыдущими заданиями, которые ранее были запущены на этом агенте. Это могут быть ключи, .env-файлы приложений, логи и т.д.
- извлечение конфиденциальных переменных среды, которые были загружены этими сборками
- получение доступа к сети для горизонтального перемещения между серверами организации
- получить облачные секреты, например, если этот агент является экземпляром EC2 в AWS

Собрав информацию, он может приступить к следующим действиям:

- добавить вредоносный код в приложение, чтобы развернуть канал от хакера до агента или даже до продуктового сервера, если вредоносный билд дойдет до деплоймента.
- при помощи инструкции `build` из Jenkinsfile запустить другие jobs (их названия есть в pullrequests), и, может быть, у него получится что-то накрутить на входных параметрах этих jobs.

На моём слайде хакер успешно стащил ключ от сервисного аккаунта.

Для того, чтобы максимально избавиться от этих неприятностей, есть несколько плагинов.

- `Authorize Project` поможет изменить пользователя по умолчанию для запуска сборок
- `Role-Based Authorization Strategy` или `Matrix Authorization Strategy` поможет в гибкой настройке разрешений для пользователя в Jenkins

Вместе это даст возможность организовать минимальные привилегии для сборки job.
