---
layout: article
---
Это относится только к `pipelines`. Для их написания используются 2 синтаксиса. В лабораторных работах ты уже видел оба.

В `Declarative` ты пишешь, что ты хочешь от Jenkins.
Это может быть настройка опций системы или инструментов, настройка агента или отдельного плагина.

```
    tools {
        go 'go-1.20'
    }

```

Здесь мы говорим: "Дженкинс, я хочу использовать в качестве go инструмент, который тебе известен как `go-1.20`!". В начале сборки Jenkins проверит, что инструмент установлен для этого пайплайна, а если его нет, то он позаботится, чтобы он появился.

Ты `задекларировал` требование, а Jenkins постарался его выполнить. Он делает это в первой неявной стадии, которая называется `declarative`.

Но вот это работает не всегда. Иногда нам нужно зайти с `заднего хода`. Например, когда в плагине нет нужной нам логики в декларативной манере. В этот `запасный выход` реализован через `Scripted`-синтаксис. Мы также видели его пример ранее:

```
        stage('build docker image') {
            steps {
                script {
                    app = docker.build("rotoro-cloud/go-webapp-sample")
			          }
            }
        }

```

Обрати внимание на блок `script`. Здесь стиль написания немного отличается от привычного. Это прямая нотация `Groovy`, и это используется для вызова метода в плагине docker. Мы также можем свободно разместить это в Jenkinsfile.

Не обязательно, чтобы наш пайплайн был декларативным. Он может быть полностью написан в `scripted`-манере.

Вот кусочки двух Jenkinsfiles, делающих одно и тоже:

```groovy
pipeline {
    agent {
        docker { image 'node:20-alpine3.17' }
    }
    stage('Test') {
    //...
    }
}
```

```groovy
node {
    docker.image('node:20-alpine3.17').inside {
        stage('Test') {
        //...
        }
    }
}
```

Это дело вкуса, лени и знания Groovy. Просто для декларативных пайплайнов нам не требуется его глубоко учить.

Напоследок, я нарисовал табличку, в которой свел их отличия.
