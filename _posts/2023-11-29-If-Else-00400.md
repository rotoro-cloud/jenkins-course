---
layout: article
---
Ок, напоследок поговорим немного не об условиях, но о похожих вещах, поскольку это также позволяет управлять исполнением шага в скриптовой манере. Это конструкция `try..catch`, которая позволяет обрабатывать исключения.

```groovy
pipeline {
    agent any
    environment {
        TZ='Tokyo'
    }
    stages {
        stage('check') {
            steps {
                script {
                    if(env.TZ == 'Moscow') {
                        echo 'Your timezone is UTC+3:00'
                    }
                    else {
                        try {
                            sh "prepare_new_tz.sh"
                        }
                        catch(e) {
                            echo "Error with the new TZ creation"
                        }
                    }
                }
            }
        }
    }
}
```

Я добавил в наш пример вызов скрипта `prepare_new_tz.sh`. Он вызывается, когда в системе на находится подходящей TZ, т.е. по оператору `else`.

Это скрипт в разработке, и мы не уверены, что он существует в данный момент в системе. Но мы бы хотели, чтобы его отсутствие никак не сказывалось на работе пайплайна. Ранее, мы проверяли наличие файла при помощи `fileExists`, но сейчас нам это не подходит. Нам требуется запустить скрипт, и, если при его исполнении есть ошибка, просто двинуться дальше, не прерывая пайплайн.

Для этого я указал блок `try`, внутри которого вызывается скрипт **prepare_new_tz.sh**. Если ним возникнут проблемы, блок `catch` исполнит свои команды, а именно в этом примере просто оповестит нас об этом. Если же все отработает как надо, **catch** не исполнится.

Я запущу на исполнение. Как ты понял, в этом конвейере всегда будет возникать событие для `else`, и будет постоянно происходить ошибка. Но наш пайплайн не будет падать, поскольку мы обработали это исключение.

Это было короткое знакомство с groovy-операторами условий. В курсе мы не ставим задачи учить Groovy, наша задача уметь прочитать чужой пайплайн, а для этого нужно знать конструкции `if..else` и `try..catch`.

Я жду тебя в следующей лекции!
