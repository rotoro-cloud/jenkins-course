---
layout: article
---
```groovy
pipeline {
    agent any
    environment {
        TZ='Tokyo'
    }
    stages {
        stage('check') {
            steps {
                script {
                    if(env.TZ == 'Moscow') {
                        echo 'Your timezone is UTC+3:00'
                    }
                    else {
                        try {
                            sh "prepare_new_tz.sh"
                        }
                        catch(e) {
                            echo "Error with the new TZ creation"
                        }
                    }
                }
            }
        }
    }
}
```

Я добавил в наш пример вызов скрипта `prepare_new_tz.sh`. Он вызывается, когда в системе не находится подходящей TZ, т.е. по оператору `else`.

Будем считать, что этот скрипт в разработке, и мы не уверены, что он существует в данный момент в системе. Но мы бы хотели, чтобы его отсутствие никак не сказывалось на работе пайплайна. Ранее, мы проверяли наличие файла при помощи `fileExists`, но сейчас нам это не подходит. Нам требуется запустить скрипт, и, если при его исполнении есть ошибка, просто двинуться дальше, не прерывая пайплайн.

Для этого я указал блок `try`, внутри которого вызывается скрипт **prepare_new_tz.sh**. Если ним возникнут проблемы, блок `catch` исполнит свои команды, а именно в этом примере просто оповестит нас об этом. Если же все отработает как надо, **catch** не исполнится.

Я запущу на исполнение. Как ты понял, в этом конвейере всегда будет возникать событие для `else`, и будет постоянно происходить ошибка. Но наш пайплайн не будет падать, поскольку мы обработали это исключение.

Это было короткое знакомство с groovy-операторами условий. В курсе мы не ставим задачи учить Groovy, наша задача уметь прочитать чужой пайплайн, а для этого нужно знать конструкции `if..else` и `try..catch`. Еще момент, если в конструкции `try` ты увидишь слово `finally`, не волнуйся - это тоже их часть, под этим блоком команды будут исполняться всегда, не важно, случилась ошибка или нет. Поэтому их используют не так часто.

Я жду тебя в следующей лекции!
