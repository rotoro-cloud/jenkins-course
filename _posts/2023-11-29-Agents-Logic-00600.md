---
layout: article
---
Напоследок давай объединим эти два подхода, разнеся стадии по разным агентам.

```
pipeline {
    agent none

    stages {
        stage('Hello') {
            steps {
                echo 'Goodbye World'
            }
        }
        stage('Goodbye') {
            agent { label '!ubuntu-agent01' }            
            steps {
                sh "echo 'Hello World'"
            }
        }
    }
}
```

Глобально на уровне pipeline у нас установлен agent в `none`, т.е. контекст агента не указан. Далее, на стадии `Hello` агент не выставлен, что значит, что будет унаследован агент **none**, т.е. никакого агента. Таким образом, первая стадия может отработать только с командой `echo`, которая не должна подключать реального агента. С другими она зафейлится. 

В стадии `Goodbye` агент переопределен на любой, но только не агент #1. И там уже может работать реальная инструкция `sh`. 

Давай проверим. Поскольку стадия уже исполнялась, она захочет пойти на агент #1. Но мы его запретили. Значит остаётся только второй агент. Зайдем в логи. Похоже, все так, как мы и предполагали. Стадия `Hello` отработала без агента. Далее вторая стадия попала на второй агент и там успешно исполнилась.

Надеюсь, стало понятнее зачем эти режимы и когда их стоит использовать. Увидимся!
