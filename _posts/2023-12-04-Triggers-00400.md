---
layout: article
---
Ок, это было про запуск по времени. А что насчет запуска одного конвейера из другого. Мы уже познакомились с механизмом `post-actions`. Сейчас мы посмотрим на `upstream` и `downstream` jobs.

Итак, под `upstream` понимается ситуация, когда одна job ждет, пока другая закончится. Важно здесь то, что первая job не в курсе того, что вторая ожидает, и ошибки в работе ожидающей никак не скажутся на работе первой. Т.е. это два независимых исполнения.

Я создал три задания: `test`, `build` и `deploy`. Все они от стандартного `Hello world`, но я немного поправил сообщения, чтобы отличать эти задания. Т.е. каждая job идентифицирует свою работу своим сообщением.

Итак, нам требуется, чтобы после исполнения сборки `test` запускалась бы `build`, а после нее `deploy`.

```
pipeline {
    agent any
    stages {
        stage('Hello') {
            steps {
                echo 'Tast app'
            }
        }
    }
}
```

Чтобы настроить, чтобы одна job отслеживала другую, я перейду в `Configure` задания `build` (поскольку мы хотим, чтобы **build** ожидал завершение **test**) и установлю триггер `Build after other projects are built`. Теперь `build` дождётся, что `test` успешен и запустит себя. Отметь, что мы можем поставить в ожидание несколько jobs, а также настроить другие статусы, не обязательно только как `успешные`. Нажму сохранить.

Теперь перейду в настройки задания `deploy`. Здесь настрою так, чтобы оно ждало успешного завершения `build` job. Сделаю это через Jenkinsfile. Открою `Pipeline Syntax` и, как в случае `cron`, создам директиву для `upstream` триггера, как ты видишь. Мне нужно, чтобы прошла сборка для `build`, поэтому вставлю сюда его название. Полученную директиву вставлю в пайплайн.

Теперь пошлю на сборку `test`. Посмотрим на дашборд. Как видишь, запуск тестов затриггерил запуск для `build`. Тут что-то не так. Третье задание не затриггерилось.

Это все та же история с Jenkinsfile. Нам необходимо произвести запуск, чтобы пайплайн обновил настройки в самом Jenkins. Я нажму кнопку для сборки `deploy`. После ее завершения снова нажму `Build Now` для `test`.

Перейду в логи запущенной job. Мы видим сообщение, что это **Test app**. Здесь также есть ссылка на билд, который был запущен по триггеру. Это задание `build`. Пройдя далее по цепочке логов, я вижу все три сборки, которые были вызваны по цепочке одна из другой. Т.е. в логах `build` мы видим, что его запустил `admin`, в `build`, что его запустил `test`, котоый запусти `admin`, а в `deploy`, что его запустил `build`, который был запущен заданием `test`.

Ок, такой способ организации работ называется `upstream`, есть обратный к нему `downstream`. Давай быстро взглянем на него и попробуем запомнить отличия.
