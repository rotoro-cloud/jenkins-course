---
layout: article
---
Поэтому я перехожу вниз в `Pipeline Syntax`. Здесь выбираю `Declarative Directive Generator` и в выпадающем списке ставлю `triggers`. Появилась кнопка `Add`, здесь я выбираю `cron`. Появилась форма создания расписания. В этой форме я могу указать время для запуска job в cron-формате. Ну или почти в нем, поскольку в формате этого триггера есть пара отличий.

Во-первых всего 5 полей. Во-вторых здесь есть специальный символ `H`, который является рандомайзером, который помогает снизить нагрузку на сервер.

Скажем, у нас расписание выглядит так: `0 0 * * *`, что значит исполнять в любой день в полночь. Очень популярная установка. Многие разработчики захотят так настроить. В итоге в 12 часов ночи у нас может запуститься колоссальное количество билдов, что очень нагрузит систему.

Создатели Jenkins советуют вместо этого выставить расписание такого вида:  `H 0 * * *`. В этом случае расписание говорит, чтобы он запускался в случайную минуту между 0 часов и 1 часом ночи в любой день. Как ты понимаешь, это существенно размажет пиковую нагрузку на систему. Строго говоря минута будет не рандомной, она зависит от названия job, поэтому минута будет постоянной для данного задания.

Я выставляю `* * * * *`, что означает каждую минуту. Дальше нажму на `Generate Declarative Directive` и скопирую полученный код. Вернусь в свой конвейер и вставлю это, как ты видишь.

Нажму на `Save`, подожду минуту и.. ничего не произойдет. Но почему? Мы же все верно написали!

Я хочу здесь показать тебе один момент, на который пока не обращал внимания в этом курсе, но это касается всех декларативных инструкций через Jenkinsfile, не только `triggers`.
После добавления конструкций вроде `optinos`, `triggers` и т.д. в Jenkinsfile изменения не вступят в силу в пайплайне, который уже находится в Jenkins. Чтобы настройки обновились, должен быть создан билд из этого задания. Случай с триггером `cron` очень хорошо это иллюстрирует, поскольку запуск не происходит.

Давай зайдем в настройки задания и посмотрим секцию `Build Triggers`. Как видишь напротив `Build periodically` нет чек-бокса. Теперь я вернусь и запущу билд на сборку. Она прошла, а я снова вернусь в настройки пайплайна. Теперь ты увидишь, что блок триггеров обновился, и в нем появилось наше расписание.

Как я сказал, это относится и к другим декларативно устанавливаемым параметрам, это такая особенность Jenkins. И пока мы смотрели чек-боксы, планировщик зашедулил новую сборку, вот она с номером 3.
