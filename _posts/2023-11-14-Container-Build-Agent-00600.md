---
layout: article
---
Вот перед тобой этот Jenkinsfile. На самом деле вторая стадия ничего не собирает, а просто выводит версию установленного golang. Я внес еще некоторые изменения. Сначала установил в указании глобального агента для всего конвейера значение `none`. Также для каждой стадии я назначил отдельного докер-агента, как ты видишь.

```groovy
pipeline {
    agent none
    stages {
        stage('test') {
            agent {
                docker { 
                    image 'golang:1.19-alpine' 
                    args '-u root:root'
                }
            }
            steps {
                sh 'apk add build-base'
                git 'https://github.com/rotoro-cloud/go-webapp-sample.git'
                sh 'go test ./...'
                sh 'go version'
            }
        }
        stage('build') {
            agent {
                docker { image 'golang:1.20-alpine' }
            }
            steps {
                sh 'go version'
            }
        }
    }
}
```

Теперь, как и прежде, stage `test` будет бежать в go v1.19, но вот собираться приложение будет уже в go v1.20. Не спрашивай меня, зачем в реальной жизни тестировать в одной версии, а компилировать в другой. Просто я не придумал примера получше.

Итак, я разнес агентов по stages, и теперь они будут бежать в разных средах. Изменю свой пайплайн, чтобы в качестве основы пайплайна использовался этот Jenkinsfile. В репо этот файл называется **`Jenkinsfile-6.40-2`.**
