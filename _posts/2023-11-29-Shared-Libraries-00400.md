---
layout: article
---
Чтобы ее попробовать в деле, создадим новый пайплайн. Перед тобой его Jenkinsfile.

```
@Library('custom-docker-lib') _
pipeline {
    agent any
    stages {
        stage('pull') {
            steps {

            }
        }
    }
}
```

Самая первая инструкция импортирует библиотеку. Обрати внимание на пробел и подчеркивание за ним. Это требуемая часть синтаксиса, и без нее работать не будет.

Также отметь для себя, что при каждом запуске пайплайна такие библиотеки будут склонированы из репо. Из этого есть несколько следствий. 

- Во-первых, такое поведение может быть неприемлемо по каким-то причинам.
- Также это причина не делать библиотеки слишком универсальными и большими.
- И это также причина тщательно оценивать свои изменения в этом репо, поскольку они сразу же применятся ко всем зависимым пайплайнам.

Теперь наш пайплайн может вызвать функции этой библиотеки. Но где эти функции находятся? И какие аргументы в них можно передать?

В нашем репозитории в ветке библиотеки перейдем в каталог `vars`. Здесь находится файл `dockerPull.groovy`, и именно он является единственной функцией данной библиотеки. Заглянем в нее.

```
def call(String projectName, String hubUser) {
    withCredentials([usernamePassword(
        credentialsId: "docker_cred",
        usernameVariable: "USER",
        passwordVariable: "PASS"
        )]) {
            sh "docker login -u '$USER' -p '$PASS' || true"
        }
    sh "docker pull ${hubUser}/${projectName}:latest"
}
```

Как видишь она принимает 2 аргумента - название проекта и пользователя на dockerhub. Потом она пытается залогинится на dockerhub и скачать последний образ для этого проекта. Для этого два раза вызывается инструкция `sh`. 

Чтобы сделать `docker login`, она использует данные из креденшилс с названием `docker_cred`. За такое обращение отвечает блок `withCredentials`.
