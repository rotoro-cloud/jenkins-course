---
layout: article
---
Ок, это было про динамическое создание. А что, если нам не нужно больше виртуальных машин? Скажем, у нас нет возможности создать больше инфраструктуры, ни он-премис, ни в облаке. Вместо этого мы бы хотели воспользоваться теми мощностями, что уже есть в наличии.

Также нам требуется собирать несколько типов одного приложения, используя разные библиотеки и компиляторы под разные дистрибутивы ОС. И мы бы хотели как-то разместить все эти библиотеки и компиляторы так, чтобы они не конфликтовали друг с другом.

Еще хочется, чтобы эти нагрузки были эфемерными, т.е. по запросу на уже существующей инфраструктуре создавались бы требуемые агенты, а когда в них нет необходимости, они бы удалялись. Удалялись бы так, чтобы не было воздействия на эти сервера, чтобы нам не приходилось их потом вычищать.

Также мы бы хотели, чтобы эти агенты не забирали бы все ресурсы у других приложений, которые исполняются рядом на этих серверах. И еще мы бы хотели единый подход к этим агентам на всех серверах, чтобы в случае проблем отдебажить это единым образом и получить какие-то логи или метрики.

В современном мире есть классный способ получить все эти преимущества - упаковать агенты в контейнеры. На самом деле, даже удобнее, если мы положим в контейнеры и сам Jenkins. Но это не сейчас. Сегодня говорим только про агенты в контейнерах.

Давай для этих целей мы будем использовать Docker и попробуем собрать наш знакомый go-пайплайн внутри агента, который запустится в Docker.
