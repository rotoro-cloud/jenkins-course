---
layout: article
---
Jenkinsfile позволяет не накликивать эти дополнительные параметры, а указать их декларативно. Например, мы можем настроить запрет на продолжение пайплайна или установить период между двумя сборками пайплайна, просто прописав это в параметре `options` в Jenkinsfile.

Список таких опций ты найдешь по этой ссылке: https://www.jenkins.io/doc/book/pipeline/syntax/#available-options

Давай начнем с очень простого Jenkinsfile, чтобы ты схватил суть.

```groovy
pipeline {
    agent any
    stages {
        stage('first') {
            steps {
                sh "echo Now: \$(date '+%Y-%m-%d %H:%M:%S')"
            }
        }
        stage('second') {
            steps {
                sh "echo Now: \$(date '+%Y-%m-%d %H:%M:%S')"
            }
        }
    }
}
```

Теперь я добавлю сюда раздел `option`, в котором укажу параметр `retry`, а в скобках укажу `3`. Этот файл есть в репо с именем `Jenkinsfile-8.30-1`:

```groovy
pipeline {
    agent any
    options {
        retry(3)
    }
    stages {
        stage('first') {
            steps {
                sh "echo Now: \$(date '+%Y-%m-%d %H:%M:%S')"
            }
        }
        stage('second') {
            steps {
                sh "echo Now: \$(date '+%Y-%m-%d %H:%M:%S')"
            }
        }
    }
}
```

Если мы его запустим, то не увидим проблем. У нас 2 стадии, первая и вторая. Все отработало штатно, и опция никак не повлияла на результат. Дело в том, что опция `retry` будет стараться повторить тот блок, где она указана, если блок отработал с ошибкой. Чтобы подтвердить это, я заставлю стадию  падать, прописав команду `error`, как ты видишь.

```groovy
pipeline {
    agent any
    options {
        retry(3)
    }
    stages {
        stage('first') {
            steps {
                error ("Just Error")
            }
        }
        stage('second') {
            steps {
                sh "echo Now: $(date '+%Y-%m-%d %H:%M:%S')"
            }
        }
    }
}
```

три из которых `first` и три `second`. Получается, что опция `retry` заставила пробежать наш пайплайн 3 раза. 

Теперь, зайдя в детали сборки, мы видим, что тут все сильно иначе. Мы видим шесть стадий вместо двух. Три из них `first` и три `second`. Получается, что опция `retry` заставила пробежать наш пайплайн 3 раза. Первая стадия ожидаемо упала, а вторая не выполнилась. Это абсолютно предсказуемое поведение. Остальные 2 повтора сработали аналогично первым двум, поскольку `retry` повторяет этот конвейер, пытаясь дождаться успешного исполнения. Как видишь, наш модификатор сильно изменил поведение конвейера.

Таких опций на самом деле немало, они задокументированы и их можно посмотреть на указанной ранее странице. Но пользоваться этим новичку не очень удобно. Для таких случаев в Jenkins есть встроенный помощник.

Давай попробуем на примере.
