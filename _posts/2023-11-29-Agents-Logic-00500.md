---
layout: article
---
Теперь я снова вношу правки в конвейер, вместо `none` выставляю `any`. Как ты помнишь, в оригинальном файле-образце было именно такое значение.

```
pipeline {
    agent none

    stages {
        stage('Hello') {
            agent any
            steps {
                sh "echo 'Hello World'"
            }
        }
    }
}
```

Этой инструкцией `agent any` мы проинструктировали Jenkins, что если для пайплайна потребуется агент, можно взять любой, что в имеется его распоряжении.

Давай снова отправим его на сборку и посмотрим консоль. Как видишь, сборку подхватил агент #3, и та успешно исполнилась. Теперь зайду в настройки и отключу этого агента.

Снова запущу эту сборку. Теперь билд исполнился на первом агенте. Jenkins знает, что третий агент сейчас вне зоны доступа и назначил сборку на другой свободный агент.

Если повторять сборки, они будут назначаться на агента #1. Дело в том, что директива `any` говорит, что использовать можно любого агнета, но Jenkins также видит, что предыдущий билд был на агенте #1. Это значит, что на том билдере остались все кэшированные файлы от прошлой сборки, а это значит, что дело пойдет быстрее. В глазах планировщика это более эффективно, поэтому он будет стараться назначать именно туда.

Думаю, логика этого назначения теперь понятна.
