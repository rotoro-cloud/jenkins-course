---
layout: article
---
Предположим, мне хотелось бы организовать сборочный сервер Jenkins отдельно и поднять его в своем кластере `Kubernetes`.

Я бы мог прописать внутри пайплайна команды, которые бы скачивали утилиту Kubernetes-CLI, потом настраивали бы ее нужным образом, потом снабжали бы ее необходимыми креденшилcами, после чего CI-процесс мог бы из пайплайна подключаться к кластеру и управлять там подами с агентами Jenkins, которые осуществляют сборку.

И это будет работать. Но во-первых это придется поддерживать.

Скажем, когда что-то измениться со стороны Kubernetes, производители плагина на это скорее всего быстро отреагируют и сообща закроют проблему. Самописное же решение придется чинить самому.

Во-вторых, через некоторое время у нас может появиться несколько пайплайнов, и для каждого придется копи-пастить этот код, что при обновлении станет адом.

Лучшее решение - скачать плагин, который подключит функциональность Kubernetes к нашему CI-серверу. Также, это позволит нам гораздо легче переключиться, если что-то сильно поменяется в конвейере.

Скажем, мы отказываемся от Kubernetes и хотим, чтобы сборка была под управлением `Docker`. Мы можем переключить плагин, добавить настройки и немного дополнить основной пайплайн, чтобы была поддержка обоих сборочных агентов, чтобы при необходимости мы могли вернуться к старой практике с Kubernetes. Если же в дальнейшем у нас появится требование, чтобы часть сборок производилась на агентах в облачных виртуальных машинах, то мы подключим модуль для этого облака. А если захотим еще большей уничаерсальности в этом, подключим плагин с `Terraform`, который будет создавать для нас виртуальные машины в разных облаках.

Это очень гибкий подход. Иногда наши задачи быстро меняются, и нам может быть практичнее иметь небольшой по мощности Jenkins-сервер с плагинами, который cможет привлечь для работы другие, более мощные инструменты облачной сборки, типа `github actions`, `google cloud build` и т.д.
